<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.3.3 (459822)"/><meta name="keywords" content="android skin"/><meta name="altitude" content="65.69195556640625"/><meta name="author" content="18513075404@163.com"/><meta name="created" content="2020-07-09 07:21:49 +0000"/><meta name="latitude" content="40.2236533950883"/><meta name="longitude" content="116.2778040938558"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-07-09 09:22:14 +0000"/><title>Android Skin 换肤</title></head><body><div><span style="font-size: 24px;">1引用</span></div><div> 1.1 Add it in your root build.gradle at the end of repositories:</div><div> </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>   allprojects {</div><div>        repositories {</div><div>            ...</div><div>            maven { url 'https://jitpack.io' }</div><div>        }</div><div>    }</div></div><div><br/></div><div> 1.2 Add the dependency</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>   dependencies {</div><div>       implementation 'com.github.lkxiaojian:AndroidSkin:Tag'</div><div>     }Ï</div></div><div><span style="font-size: 24px;">2使用</span></div><div><span style="font-size: 24px;">  1.如果使用静态皮肤包 就别集成框架了 直接设置</span></div><div><span style="font-size: 24px;">delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_YES. //日间</span></div><div><span style="font-size: 24px;">delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_NO//夜间</span></div><div><span style="font-size: 24px;">即可 （查看</span><span style="font-size: 14px;">3.1静态换肤</span><span style="font-size: 24px;">）</span></div><div><span style="font-size: 24px;">2.2  </span></div><div><span style="font-size: 24px;">  在Application 中调用 </span><span style="font-size: 24px;">SkinManager.init(this)</span></div><div><span style="font-size: 24px;">    Activity </span></div><div><span style="font-size: 24px;">    Activity 继承 </span><span style="font-size: 24px;">SkinActivity  </span></div><div><span style="font-size: 24px;">     加载动态皮肤包 </span><span style="font-size: 24px;">skinDynamic(skinPath, R.color.skin_item_color) //1外部路径 2主题颜色</span></div><div><span style="font-size: 24px;">     还原皮肤包 </span><span style="font-size: 24px;">defaultSkin(R.color.colorPrimary)</span></div><div><span style="font-size: 24px;"><br/></span></div><div><span style="font-size: 24px;"> 自定义VIew  </span></div><div><span style="font-size: 24px;"> 需要 </span><span style="font-size: 24px;">继承</span><span style="font-size: 24px;"> </span><span style="font-size: 24px;">ViewsMatch  查看domo 中的用法（可以封装一个BaseView ，看项目需求）</span></div><div><span style="font-size: 24px;"> </span><span style="font-size: 24px;">com.zky.myskin.views.CustomCircleView</span></div><div><span style="font-size: 24px;"><br/></span></div><div><span style="font-size: 24px;">Fragment </span></div><div><span style="font-size: 24px;">调用 </span><span style="font-size: 24px;">SkinManager.instance?.applyViews(view)</span></div><div><span style="font-size: 24px;"><br/></span></div><div><span style="font-size: 24px;">RecycleView  </span></div><div><span style="font-size: 24px;">两种方式 1.把recycleView 复用关闭 </span><span style="font-size: 24px;">holder.setIsRecyclable(true) (不建议)</span></div><div><span style="font-size: 24px;">在viewHodle 中调用 </span><span style="font-size: 24px;">SkinManager.instance?.applyViews(view)</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div>public class BaseHolder extends RecyclerView.ViewHolder{</div><div><div><br/></div><div><br/></div></div><div>    public BaseHolder(@NonNull View itemView) {</div><div>        super(itemView);</div><div>        SkinManager.Companion.getInstance().applyViews(itemView);</div><div>    }</div><div>}</div></div></div><div><span style="font-size: 24px;"><br/></span></div><div><br/></div><div><span style="font-size: 24px;">3原理</span></div><div><font style="font-size: 24px;"><br/></font></div><div><span style="font-size: 14px;">3.1静态换肤</span></div><div><span style="font-size: 14px;">    </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div><br/></div><div>//Kotlin code  </div><div><br/></div><div>delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_YES. //日间</div><div><br/></div><div>delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_NO//夜间</div><div><br/></div><div>在对应的src 中新建 drawable-night values-night 即可  </div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div></div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div></div><div><br/></div><div><span style="font-size: 18px;">3.2 动态换肤 </span></div><div><span style="font-size: 18px;">  在Acvitity 创建布局都需要 </span><span style="font-size: 18px;">setContentView()  </span></div><div><span style="font-size: 18px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>@Override</div><div>public void setContentView(int resId) {</div><div>    ensureSubDecor();</div><div>    //android 总布局 是个FrameLayout 我们所有的布局都加载这个上面 R.id.content 是系统的ID</div><div>    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</div><div>    contentParent.removeAllViews();</div><div><font style="color: rgb(234, 18, 5); --inversion-type-color:  simple;">    LayoutInflater.from(mContext).inflate(resId, contentParent);</font></div><div>    mAppCompatWindowCallback.getWrapped().onContentChanged();</div><div>}</div></div><div> </div><div>   LayoutInflater.from(mContext).inflate(resId, contentParent);  这个才是加载布局实际操作的</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>   public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {</div><div>    final Resources res = getContext().getResources();</div><div>    if (DEBUG) {</div><div>        Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" ("</div><div>              + Integer.toHexString(resource) + ")");</div><div>    }</div><div><div><br/></div><div>    //如果创建过这个view ,内部通过反射 得到 </div></div><div>    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);</div><div>    if (view != null) {</div><div>        return view;</div><div>    }</div><div>   //得到xml 解析器</div><div>    XmlResourceParser parser = res.getLayout(resource);</div><div>    try {</div><div>       <font style="color: rgb(255, 4, 4); --inversion-type-color:  simple;"> return inflate(parser, root, attachToRoot);</font></div><div>    } finally {</div><div>        parser.close();</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 16px; --inversion-type-color:  simple; color: rgb(94, 117, 142); font-family: Menlo;">inflate(parser, root, attachToRoot) </span></div><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>由于代码过多 简略下</div><div>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {</div><div>    synchronized (mConstructorArgs) {</div><div>        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");</div><div><div><br/></div><div><br/></div></div><div>        final Context inflaterContext = mContext;</div><div>         // 资源管理器</div><div><font style="color: rgb(255, 4, 4); --inversion-type-color:  simple;">        final AttributeSet attrs = Xml.asAttributeSet(parser);</font></div><div>        Context lastContext = (Context) mConstructorArgs[0];</div><div>        mConstructorArgs[0] = inflaterContext;</div><div>        View result = root;</div><div> ...</div><div><div>       </div></div><div><div>     <font style="color: rgb(255, 4, 4); --inversion-type-color:  simple;"> rInflate(parser, root, inflaterContext, attrs, false);</font></div></div><div><br/></div><div> ...</div><div>        return result;</div><div>    }</div><div>}</div><div><div><br/></div><div><br/></div></div></div><div><span style="--inversion-type-color:  simple; color: rgb(36, 43, 25);"> //解析xml 布局 用的是 Pull解析xml(while 循环  把view 添加到viewGroup)  </span></div><div><br/></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>void rInflate(XmlPullParser parser, View parent, Context context,</div><div>        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {</div><div><div><br/></div><div><br/></div></div><div>    final int depth = parser.getDepth();</div><div>    int type;</div><div>    boolean pendingRequestFocus = false;</div><div><div><br/></div><div><br/></div></div><div>    while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div>            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {</div><div><div><br/></div><div><br/></div></div><div>    ..</div><div><br/></div><div>          <font style="color: rgb(192, 13, 6); --inversion-type-color:  simple;"> final View view = createViewFromTag(parent, name, context, attrs);</font></div><div>            final ViewGroup viewGroup = (ViewGroup) parent;</div><div>            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div>            rInflateChildren(parser, view, attrs, true);</div><div>            viewGroup.addView(view, params);</div><div>  ..</div><div><div><br/></div><div><br/></div></div><div>  </div><div>}</div><div><div><br/></div><div><br/></div></div></div></div><div><br/></div><div><br/></div><div><span style="color: rgb(36, 43, 25); --inversion-type-color:  simple;">rInflate </span><span style="--inversion-type-color:  simple; color: rgb(36, 43, 25);">其中调用 tryCreateView（） 方法</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>public final View tryCreateView(@Nullable View parent, @NonNull String name,</div><div>    @NonNull Context context,</div><div>    @NonNull AttributeSet attrs) {</div><div>    if (name.equals(TAG_1995)) {</div><div>        // Let's party like it's 1995!</div><div>        return new BlinkLayout(context, attrs);</div><div>    }</div><div><div><br/></div><div><br/></div></div><div>    View view;</div><div>     //这两个才是 创建view的方法  布局加载工厂</div><div>     //mFactory 是mFactory2 的父类</div><div>    if (mFactory2 != null) {</div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div>      <font style="color: rgb(255, 4, 21); --inversion-type-color:  simple;">  view = mFactory2.onCreateView(parent, name, context, attrs);</font></div><div>    } else if (mFactory != null) {</div><div>       <font style="color: rgb(246, 4, 5); --inversion-type-color:  simple;"> view = mFactory.onCreateView(name, context, attrs);</font></div><div>    } else {</div><div>        view = null;</div><div>    }</div><div>    if (view == null &amp;&amp; mPrivateFactory != null) {</div><div>        view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div>    }</div><div>    return view;</div><div>}</div></div><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><div><span style="font-size: 16px;">大致流程是 </span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>通过布局ID (resID) —&gt; XmlResourceParser —&gt; 通过while 循环添加 </div><div>{</div><div>   createViewFromTag() 这个方法里面区分是否是自定义view（if (-1 == name.indexOf('.')) {}）。</div><div>   不是 android.view.* 这样的路径</div><div>   不过都通过反射实例化对象 （如果有缓冲，冲缓存中读取）</div><div>   然后 根布局.addView</div><div>}</div><div><br/></div></div><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><div><span style="font-size: 16px; --inversion-type-color:  simple; color: rgb(25, 37, 29);">在看 </span><span style="--inversion-type-color:  simple; color: rgb(255, 4, 4);">super.onCreate</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>override fun onCreate(savedInstanceState: Bundle?) {</div><div>   </div><div><font style="color: rgb(255, 4, 4); --inversion-type-color:  simple;">    super.onCreate(savedInstanceState)</font></div><div>}</div></div><div><br/></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>@Override</div><div>protected void onCreate(@Nullable Bundle savedInstanceState) {</div><div>    final AppCompatDelegate delegate = getDelegate();</div><div>  <font style="color: rgb(255, 4, 4); --inversion-type-color:  simple;">  delegate.installViewFactory();</font></div><div>    delegate.onCreate(savedInstanceState);</div><div>    super.onCreate(savedInstanceState);</div><div>}</div></div><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>@Override</div><div>public void installViewFactory() {</div><div>    LayoutInflater layoutInflater = LayoutInflater.from(mContext);</div><div>    if (layoutInflater.getFactory() == null) {</div><div>  <font style="color: rgb(255, 4, 17); --inversion-type-color:  simple;">      LayoutInflaterCompat.setFactory2(layoutInflater, this);</font></div><div>    } else {</div><div>        if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImpl)) {</div><div>            Log.i(TAG, "The Activity's LayoutInflater already has a Factory installed"</div><div>                    + " so we can not install AppCompat's");</div><div>        }</div><div>    }</div><div>}</div></div><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><div><span style="font-size: 16px;">这个方法设置 Factory 的 如果是null  抛出异常</span></div><div><span style="font-size: 16px;">所以我们在 </span><span style="--inversion-type-color:  simple; color: rgb(255, 4, 4);">   super.onCreate(savedInstanceState) </span><span style="color: rgb(26, 35, 25); --inversion-type-color:  simple;">添加</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>val layoutInflater = LayoutInflater.from(this)</div><div>LayoutInflaterCompat.setFactory2(layoutInflater, this)</div></div></div><div><span style="font-size: 16px;">这样就不会抛出异常了</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">然后在</span><span style="background-color: rgb(43, 43, 43); color: rgb(255, 198, 109); font-family: Menlo; font-size: 12pt;">onCreateView 中收集资源就可以了</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>override fun onCreateView(parent: View?, name: String, context: Context, attrs: AttributeSet): View? {</div><div>    if (openChangeSkin()) {</div><div>        if (viewInflater == null) {</div><div>            viewInflater = CustomAppCompatViewInflater(context)</div><div>        }</div><div>        viewInflater!!.setName(name)</div><div>        viewInflater!!.setAttrs(attrs)</div><div>        return viewInflater!!.autoMatch()</div><div>    }</div><div>    return super.onCreateView(parent, name, context, attrs)</div><div>}</div></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">如TextView</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>&lt;!-- TextView控件属性 --&gt;</div><div>&lt;declare-styleable name="SkinnableTextView"&gt;</div><div>    &lt;attr name="android:background" /&gt;</div><div>    &lt;attr name="android:textColor" /&gt;</div><div>    &lt;attr name="android:drawableBottom" /&gt;</div><div>    &lt;attr name="android:drawableLeft" /&gt;</div><div>    &lt;attr name="android:drawableRight" /&gt;</div><div>    &lt;attr name="android:drawableTop" /&gt;</div><div>    &lt;!-- 字体属性 --&gt;</div><div>    &lt;attr name="custom_typeface" /&gt;</div><div>&lt;/declare-styleable&gt;</div></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">设置textColor 属性</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>// 根据自定义属性，获取styleable中的textColor属性</div><div>key = R.styleable.SkinnableTextView[R.styleable.SkinnableTextView_android_textColor]</div><div>val textColorResourceId = attrsBean.getViewResource(key)</div><div>if (textColorResourceId &gt; 0) {</div><div>    if (instance!!.isDefaultSkin) {</div><div>        val color = ContextCompat.getColorStateList(context, textColorResourceId)</div><div>        setTextColor(color)</div><div>    } else {</div><div>        val color = instance!!.getColorStateList(textColorResourceId)</div><div>        setTextColor(color)</div><div>    }</div><div>}</div></div></div><div><span style="font-size: 16px;"> </span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">读取外部皮肤包</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>fun loaderSkinResources(skinPath: String?) {</div><div>    // 如果没有皮肤包或者没做换肤动作，方法不执行直接返回！</div><div>    if (TextUtils.isEmpty(skinPath)) {</div><div>        isDefaultSkin = true</div><div>        return</div><div>    }</div><div>    // 优化：app冷启动、热启动可以取缓存对象</div><div>    if (cacheSkin.containsKey(skinPath)) {</div><div>        isDefaultSkin = false</div><div>        val skinCache = cacheSkin[skinPath]</div><div>        if (null != skinCache) {</div><div>            skinResources = skinCache.skinResources</div><div>            skinPackageName = skinCache.skinPackageName</div><div>            return</div><div>        }</div><div>    }</div><div>    try { // 创建资源管理器（此处不能用：application.getAssets()）</div><div>        val assetManager = AssetManager::class.java.newInstance()</div><div>        // 由于AssetManager中的addAssetPath和setApkAssets方法都被@hide，目前只能通过反射去执行方法</div><div>        val addAssetPath = assetManager.javaClass.getDeclaredMethod(ADD_ASSET_PATH, String::class.java)</div><div>        // 设置私有方法可访问</div><div>        addAssetPath.isAccessible = true</div><div>        // 执行addAssetPath方法</div><div>        addAssetPath.invoke(assetManager, skinPath)</div><div><div><br/></div><div><br/></div></div><div>      // 创建加载外部的皮肤包(mySkin.skin.apk  名字随便去)文件Resources（注：依然是本应用加载）</div><div>        skinResources = Resources(assetManager,</div><div>                appResources.displayMetrics, appResources.configuration)</div><div>        // 根据apk文件路径（皮肤包也是apk文件），获取该应用的包名。兼容5.0 - 9.0（亲测）</div><div>        skinPackageName = application.packageManager</div><div>                .getPackageArchiveInfo(skinPath, PackageManager.GET_ACTIVITIES).packageName</div><div>        // 无法获取皮肤包应用的包名，则加载app内置资源</div><div>        isDefaultSkin = TextUtils.isEmpty(skinPackageName)</div><div>        if (!isDefaultSkin) {</div><div>            cacheSkin[skinPath] = SkinCache(skinResources, skinPackageName)</div><div>        }</div><div>        Log.e("skinPackageName &gt;&gt;&gt; ", skinPackageName)</div><div>    } catch (e: Exception) {</div><div>        e.printStackTrace()</div><div>        // 发生异常，预判：通过skinPath获取skinPacakageName失败！</div><div>        isDefaultSkin = true</div><div>    }</div><div>}</div></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div></body></html>